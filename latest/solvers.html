<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers · StructuredOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StructuredOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="tutorial.html">Quick Tutorial Guide</a></li><li><a class="toctext" href="expressions.html">Expressions</a></li><li><a class="toctext" href="functions.html">Functions</a></li><li class="current"><a class="toctext" href="solvers.html">Solvers</a><ul class="internal"><li><a class="toctext" href="#Minimizing-a-problem-1">Minimizing a problem</a></li><li><a class="toctext" href="#Specifying-solver-and-options-1">Specifying solver and options</a></li><li><a class="toctext" href="#Build-and-solve-1">Build and solve</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="demos.html">Demos</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="solvers.html">Solvers</a></li></ul><a class="edit-page" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/master/docs/src/solvers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solvers-1" href="#Solvers-1">Solvers</a></h1><h2><a class="nav-anchor" id="Minimizing-a-problem-1" href="#Minimizing-a-problem-1">Minimizing a problem</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.@minimize" href="#StructuredOptimization.@minimize"><code>StructuredOptimization.@minimize</code></a> — <span class="docstring-category">Macro</span>.</div><div><p><code>@minimize cost [st ctr] [with slv_opt]</code></p><p>Minimize a given problem with cost function <code>cost</code>, constraints <code>ctr</code> and solver options <code>slv_opt</code>. </p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; A, b = randn(10,4), randn(10);

julia&gt; @minimize ls(A*x-b) + 0.5*norm(x);
    it |      gamma |        fpr |        tau |        FBE |
 ------|------------|------------|------------|------------|
     1 | 2.9152e-02 | 2.7656e+00 | 1.0000e+00 | 5.5181e+00 |
     9 | 2.9152e-02 | 9.9682e-05 | 1.0000e+00 | 4.4086e+00 |

julia&gt; @minimize ls(A*x-b) st x &gt;= 0.;
    it |      gamma |        fpr |        tau |        FBE |
 ------|------------|------------|------------|------------|
     1 | 5.8304e-02 | 1.0068e+00 | 1.0000e+00 | 6.6282e+00 |
     3 | 5.8304e-02 | 9.5210e-16 | 1.0000e+00 | 6.5654e+00 |

julia&gt; it, slv = @minimize ls(A*x-b) st norm(x) == 2.0 with PG(maxit = 5);
    it |      gamma |        fpr |
 ------|------------|------------|
     1 | 6.1373e-02 | 2.2090e+01 |
     5 | 3.0686e-02 | 5.5190e-01 |
</code></pre><p>Returns as output a tuple containing the number of iterations and the constructed solver.</p></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/minimize.jl#L3-L35">source</a></section><div class="admonition note"><div class="admonition-title">Problem warm-starting</div><div class="admonition-text"><p>By default <em>warm-starting</em> is always enabled. For example, if two problems that utilize the same variables are solved consecutively, the second one will be automatically warm-started by the solution of the first one. That is because the variables are always linked to their respective data vectors. If one wants to avoid this, the optimization variables needs to be manually re-initialized before solving the second problem e.g. to a vector of zeros: <code>~x .= 0.0</code>.</p></div></div><h2><a class="nav-anchor" id="Specifying-solver-and-options-1" href="#Specifying-solver-and-options-1">Specifying solver and options</a></h2><p>As shown above it is possible to choose the type of algorithm and specify its options by creating a <code>Solver</code> object. Currently, the following algorithms are supported:</p><ul><li><p><em>Proximal Gradient (PG)</em> <a href="http://www.mit.edu/~dimitrib/PTseng/papers/apgm.pdf">[1]</a>, <a href="http://epubs.siam.org/doi/abs/10.1137/080716542">[2]</a></p></li><li><p><em>Fast Proximal Gradient (FPG)</em> <a href="http://www.mit.edu/~dimitrib/PTseng/papers/apgm.pdf">[1]</a>, <a href="http://epubs.siam.org/doi/abs/10.1137/080716542">[2]</a></p></li><li><p><em>ZeroFPR</em> <a href="https://arxiv.org/abs/1606.06256">[3]</a></p></li><li><p><em>PANOC</em> <a href="https://doi.org/10.1109/CDC.2017.8263933">[4]</a></p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.PG" href="#StructuredOptimization.PG"><code>StructuredOptimization.PG</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>PG(;kwargs...)</code></p><p>Creates an object <code>PG</code> containing the options of the Proximal Gradient solvers:</p><ul><li><p><code>gamma</code>, stepsize (default: unspecified, determined automatically)</p></li><li><p><code>maxit</code>, maximum number of iteration (default: <code>10000</code>)</p></li><li><p><code>tol</code>, halting tolerance on the fixed-point residual (default: <code>1e-4</code>)</p></li><li><p><code>adaptive</code>, adaptively adjust <code>gamma</code> (default: <code>false</code> if <code>gamma</code> is provided)</p></li><li><p><code>fast</code>, enables accelerated method (default: <code>false</code>)</p></li><li><p><code>verbose</code>, verbosity level (default: <code>1</code>)</p></li><li><p><code>verbose_freq</code>, verbosity frequency for <code>verbose = 1</code> (default: <code>100</code>)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/solvers_options.jl#L10-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.FPG" href="#StructuredOptimization.FPG"><code>StructuredOptimization.FPG</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>FPG(;kwargs...)</code></p><p>Same as <code>PG</code>, creates the options of the Fast Proximal Gradient solver. </p></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/solvers_options.jl#L31-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.ZeroFPR" href="#StructuredOptimization.ZeroFPR"><code>StructuredOptimization.ZeroFPR</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>ZeroFPR(;kwargs...)</code></p><p>Creates an object <code>ZeroFPR</code> containing the options of the ZeroFPR solver:</p><ul><li><p><code>gamma</code>, stepsize (default: unspecified, determined automatically)</p></li><li><p><code>maxit</code>, maximum number of iteration (default: <code>10000</code>)</p></li><li><p><code>tol</code>, halting tolerance on the fixed-point residual (default: <code>1e-4</code>)</p></li><li><p><code>adaptive</code>, adaptively adjust <code>gamma</code> (default: <code>false</code> if <code>gamma</code> is provided)</p></li><li><p><code>fast</code>, enables accelerated method (default: <code>false</code>)</p></li><li><p><code>verbose</code>, verbosity level (default: <code>1</code>)</p></li><li><p><code>verbose_freq</code>, verbosity frequency for <code>verbose = 1</code> (default: <code>100</code>)</p></li><li><p><code>memory</code>, memory of the <code>LBFGS</code> operator (default: <code>10</code> )</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/solvers_options.jl#L48-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.PANOC" href="#StructuredOptimization.PANOC"><code>StructuredOptimization.PANOC</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>ZeroFPR(;kwargs...)</code></p><p>Creates an object <code>PANOC</code> containing the options of the PANOC solver:</p><ul><li><p><code>gamma</code>, stepsize (default: unspecified, determined automatically)</p></li><li><p><code>maxit</code>, maximum number of iteration (default: <code>10000</code>)</p></li><li><p><code>tol</code>, halting tolerance on the fixed-point residual (default: <code>1e-4</code>)</p></li><li><p><code>adaptive</code>, adaptively adjust <code>gamma</code> (default: <code>false</code> if <code>gamma</code> is provided)</p></li><li><p><code>fast</code>, enables accelerated method (default: <code>false</code>)</p></li><li><p><code>verbose</code>, verbosity level (default: <code>1</code>)</p></li><li><p><code>verbose_freq</code>, verbosity frequency for <code>verbose = 1</code> (default: <code>100</code>)</p></li><li><p><code>memory</code>, memory of the <code>LBFGS</code> operator (default: <code>10</code> )</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/solvers_options.jl#L77-L91">source</a></section><h2><a class="nav-anchor" id="Build-and-solve-1" href="#Build-and-solve-1">Build and solve</a></h2><p>The macro <a href="solvers.html#StructuredOptimization.@minimize"><code>@minimize</code></a> automatically parse and solve the problem. An alternative syntax is given by the function <a href="solvers.html#StructuredOptimization.problem"><code>problem</code></a> and <a href="solvers.html#StructuredOptimization.solve"><code>solve</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.problem" href="#StructuredOptimization.problem"><code>StructuredOptimization.problem</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>problems(terms...)</code></p><p>Constructs a problem.</p><p><strong>Example</strong></p><pre><code class="language-julia">
julia&gt; x = Variable(4)
Variable(Float64, (4,))

julia&gt; A, b = randn(10,4), randn(10);

julia&gt; p = problem(ls(A*x-b), norm(x) &lt;= 1)
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/syntax/problem.jl#L3-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.solve" href="#StructuredOptimization.solve"><code>StructuredOptimization.solve</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>solve(terms::Tuple, solver_opt::ForwardBackwardSolver)</code></p><p>Takes as input a tuple containing the terms defining the problem and the solver options.</p><p>Solves the problem returning a tuple containing the iterations taken and the build solver.</p><p><strong>Example</strong></p><pre><code class="language-julia">
julia&gt; x = Variable(4)
Variable(Float64, (4,))

julia&gt; A, b = randn(10,4), randn(10);

julia&gt; solve(p,PG());
    it |      gamma |        fpr |
 ------|------------|------------|
     1 | 7.6375e-02 | 1.8690e+00 |
    12 | 7.6375e-02 | 9.7599e-05 |
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/build_solve.jl#L95-L119">source</a></section><p>It is important to stress out that the <code>Solver</code> objects created using the functions above (<a href="solvers.html#StructuredOptimization.PG"><code>PG</code></a>, <a href="solvers.html#StructuredOptimization.FPG"><code>FPG</code></a>, etc.) specify only the type of algorithm to be used together with its options. The actual solver (namely the one of <a href="https://github.com/kul-forbes/ProximalAlgorithms.jl"><code>ProximalAlgorithms.jl</code></a>) is constructed altogether with the problem formulation. The problem parsing procedure can be separated from the solver application using the functions <a href="solvers.html#StructuredOptimization.build"><code>build</code></a> and <a href="solvers.html#StructuredOptimization.solve!"><code>solve!</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.build" href="#StructuredOptimization.build"><code>StructuredOptimization.build</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>build(terms::Tuple, solver_opt::ForwardBackwardSolver)</code></p><p>Takes as input a tuple containing the terms defining the problem and the solver options.</p><p>Returns a tuple containing the optimization variables and the built solver.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; x = Variable(4)
Variable(Float64, (4,))

julia&gt; A, b = randn(10,4), randn(10);

julia&gt; p = problem( ls(A*x - b ) , norm(x) &lt;= 1 );

julia&gt; build(p, PG());
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/build_solve.jl#L3-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.solve!" href="#StructuredOptimization.solve!"><code>StructuredOptimization.solve!</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>solve!( x_solver )</code></p><p>Takes as input a tuple containing the optimization variables and the built solver.</p><p>Solves the problem returning a tuple containing the iterations taken and the build solver.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; x = Variable(4)
Variable(Float64, (4,))

julia&gt; A, b = randn(10,4), randn(10);

julia&gt; p = problem( ls(A*x - b ) , norm(x) &lt;= 1 );

julia&gt; x_solver = build(p, PG(verbose = 0));

julia&gt; solve!(x_solver);
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/2771bb11cb1c7efc484984372b2ef4953729a708/src/solvers/build_solve.jl#L61-L84">source</a></section><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><p><a href="http://www.mit.edu/~dimitrib/PTseng/papers/apgm.pdf">[1]</a> Tseng, <em>On Accelerated Proximal Gradient Methods for Convex-Concave Optimization</em> (2008).</p><p><a href="http://epubs.siam.org/doi/abs/10.1137/080716542">[2]</a> Beck, Teboulle, <em>A Fast Iterative Shrinkage-Thresholding Algorithm for Linear Inverse Problems</em>, SIAM Journal on Imaging Sciences, vol. 2, no. 1, pp. 183-202 (2009).</p><p><a href="https://arxiv.org/abs/1606.06256">[3]</a> Themelis, Stella, Patrinos, <em>Forward-backward envelope for the sum of two nonconvex functions: Further properties and nonmonotone line-search algorithms</em>, arXiv:1606.06256 (2016).</p><p><a href="https://doi.org/10.1109/CDC.2017.8263933">[4]</a> Stella, Themelis, Sopasakis, Patrinos, <em>A simple and efficient algorithm for nonlinear model predictive control</em>, 56th IEEE Conference on Decision and Control (2017).</p><footer><hr/><a class="previous" href="functions.html"><span class="direction">Previous</span><span class="title">Functions</span></a><a class="next" href="demos.html"><span class="direction">Next</span><span class="title">Demos</span></a></footer></article></body></html>
