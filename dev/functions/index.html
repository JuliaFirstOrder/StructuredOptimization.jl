<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · StructuredOptimization</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StructuredOptimization</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../tutorial/">Quick Tutorial Guide</a></li><li><a class="toctext" href="../expressions/">Expressions</a></li><li class="current"><a class="toctext" href>Functions</a><ul class="internal"><li><a class="toctext" href="#Smooth-functions-1">Smooth functions</a></li><li><a class="toctext" href="#Nonsmooth-functions-1">Nonsmooth functions</a></li><li><a class="toctext" href="#Inequality-constraints-1">Inequality constraints</a></li><li><a class="toctext" href="#Equality-constraints-1">Equality constraints</a></li><li><a class="toctext" href="#Smoothing-1">Smoothing</a></li><li><a class="toctext" href="#Duality-1">Duality</a></li></ul></li><li><a class="toctext" href="../solvers/">Solvers</a></li><li><a class="toctext" href="../demos/">Demos</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Functions</a></li></ul><a class="edit-page" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/master/docs/src/functions.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Functions-and-constraints-1" href="#Functions-and-constraints-1">Functions and constraints</a></h1><p>Once an expression is created it is possible to create the <code>Term</code>s defining the optimization problem. These can consists of either <a href="#Smooth-functions-1">Smooth functions</a>,  <a href="#Nonsmooth-functions-1">Nonsmooth functions</a>, <a href="#Inequality-constraints-1">Inequality constraints</a> or <a href="#Equality-constraints-1">Equality constraints</a>.</p><h2><a class="nav-anchor" id="Smooth-functions-1" href="#Smooth-functions-1">Smooth functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.ls" href="#StructuredOptimization.ls"><code>StructuredOptimization.ls</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">ls(x::AbstractExpression)</code></pre><p>Returns the squared norm (least squares) of <code>x</code>:</p><div>\[f (\mathbf{x}) = \frac{1}{2} \| \mathbf{x} \|^2\]</div><p>(shorthand of <code>1/2*norm(x)^2</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L64-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.huberloss" href="#StructuredOptimization.huberloss"><code>StructuredOptimization.huberloss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">huberloss(x::AbstractExpression, ρ=1.0)</code></pre><p>Applies the Huber loss function:</p><div>\[f(\mathbf{x}) = \begin{cases}
  \tfrac{1}{2}\| \mathbf{x} \|^2 &amp; \text{if} \ \| \mathbf{x} \| \leq \rho \\
  \rho (\| \mathbf{x} \| - \tfrac{\rho}{2}) &amp; \text{otherwise}.
\end{cases}\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L171-L181">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.sqrhingeloss" href="#StructuredOptimization.sqrhingeloss"><code>StructuredOptimization.sqrhingeloss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sqrhingeloss(x::AbstractExpression, y::Array)</code></pre><p>Applies the squared Hinge loss function</p><div>\[f( \mathbf{x} ) = \sum_{i} \max\{0, 1 - y_i x_i \}^2,\]</div><p>where <code>y</code> is an array containing <span>$y_i$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L108-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.crossentropy" href="#StructuredOptimization.crossentropy"><code>StructuredOptimization.crossentropy</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">crossentropy(x::AbstractExpression, y::Array)</code></pre><p>Applies the cross entropy loss function:</p><div>\[f(\mathbf{x}) = -1/N \sum_{i}^{N} y_i \log (x_i)+(1-y_i) \log (1-x_i),\]</div><p>where <code>y</code> is an array of length <span>$N$</span> containing <span>$y_i$</span> having <span>$0 \leq y_i \leq 1$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L124-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.logisticloss" href="#StructuredOptimization.logisticloss"><code>StructuredOptimization.logisticloss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logbarrier(x::AbstractExpression, y::AbstractArray)</code></pre><p>Applies the logistic loss function:</p><div>\[f(\mathbf{x}) = \sum_{i} \log(1+ \exp(-y_i x_i)),\]</div><p>where <code>y</code> is an array containing <span>$y_i$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L140-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.dot" href="#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dot(c::AbstractVector, x::AbstractExpression)</code></pre><p>Applies the function:</p><div>\[f(\mathbf{x}) = \mathbf{c}^{T}\mathbf{x}.\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L214-L221">source</a></section><h2><a class="nav-anchor" id="Nonsmooth-functions-1" href="#Nonsmooth-functions-1">Nonsmooth functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">norm(x::AbstractExpression, p=2, [q,] [dim=1])</code></pre><p>Returns the norm of <code>x</code>.</p><p>Supported norms:</p><ul><li><p><code>p = 0</code> <span>$l_0$</span>-pseudo-norm</p></li><li><p><code>p = 1</code> <span>$l_1$</span>-norm</p></li><li><p><code>p = 2</code> <span>$l_2$</span>-norm</p></li><li><p><code>p = Inf</code> <span>$l_{\infty}$</span>-norm</p></li><li><p><code>p = *</code> nuclear norm</p></li><li><p><code>p = 2</code>, <code>q = 1</code> <span>$l_{2,1}$</span> mixed norm (aka Sum-of-<span>$l_2$</span>-norms)</p></li></ul><div>\[f(\mathbf{X}) = \sum_i \| \mathbf{x}_i \|\]</div><p>where <span>$\mathbf{x}_i$</span> is the <span>$i$</span>-th column if <code>dim == 1</code> (or row if  <code>dim == 2</code>) of <span>$\mathbf{X}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L6-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.maximum" href="#Base.maximum"><code>Base.maximum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">maximum(x::AbstractExpression)</code></pre><p>Applies the function:</p><div>\[f(\mathbf{x}) = \max \{x_i : i = 1,\ldots, n \}.\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L187-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.sumpositive" href="#StructuredOptimization.sumpositive"><code>StructuredOptimization.sumpositive</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sumpositive(x::AbstractExpression, ρ=1.0)</code></pre><p>Applies the function:</p><div>\[f(\mathbf{x}) = \sum_i \max \{x_i, 0\}.\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L200-L207">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.hingeloss" href="#StructuredOptimization.hingeloss"><code>StructuredOptimization.hingeloss</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hingeloss(x::AbstractExpression, y::Array)</code></pre><p>Applies the Hinge loss function</p><div>\[f( \mathbf{x} ) = \sum_{i} \max\{0, 1 - y_i x_i \},\]</div><p>where <code>y</code> is an array containing <span>$y_i$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L92-L100">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.logbarrier" href="#StructuredOptimization.logbarrier"><code>StructuredOptimization.logbarrier</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">logbarrier(x::AbstractExpression)</code></pre><p>Applies the log barrier function:</p><div>\[f(\mathbf{x}) = -\sum_i \log( x_i ).\]</div></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L156-L163">source</a></section><h2><a class="nav-anchor" id="Inequality-constraints-1" href="#Inequality-constraints-1">Inequality constraints</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:&lt;=" href="#Base.:&lt;="><code>Base.:&lt;=</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Inequalities constrains</p><p><strong>Norm Inequalities constraints</strong></p><ul><li><p><code>norm(x::AbstractExpression, 0) &lt;= n::Integer</code></p><p><span>$\mathrm{nnz}(\mathbf{x}) \leq n$</span></p></li><li><p><code>norm(x::AbstractExpression, 1) &lt;= r::Number</code></p><p><span>$\sum_i \| x_i \| \leq r$</span></p></li><li><p><code>norm(x::AbstractExpression, 2) &lt;= r::Number</code></p><p><span>$\| \mathbf{x} \| \leq r$</span></p></li><li><p><code>norm(x::AbstractExpression, Inf) &lt;= r::Number</code></p><p><span>$\max \{ x_1, x_2, \dots \}  \leq r$</span></p></li></ul><p><strong>Box inequality constraints</strong></p><ul><li><p><code>x::AbstractExpression &lt;= u::Union{AbstractArray, Real}</code></p><p><span>$x_i \leq u_i$</span></p></li><li><p><code>x::AbstractExpression &gt;= l::Union{AbstractArray, Real}</code></p><p><span>$x_i \geq l_i$</span></p><p>Notice that the notation <code>x in [l,u]</code> is also possible.</p></li></ul><p><strong>Rank inequality constraints</strong></p><ul><li><p><code>rank(X::AbstractExpression) &lt;= n::Integer</code></p><p><span>$\mathrm{rank}(\mathbf{X}) \leq r$</span></p><p>Notice that the expression <code>X</code> must have a codomain with dimension equal to 2.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L229-L270">source</a></section><h2><a class="nav-anchor" id="Equality-constraints-1" href="#Equality-constraints-1">Equality constraints</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:==" href="#Base.:=="><code>Base.:==</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Equalities constraints</p><p><strong>Affine space constraint</strong></p><ul><li><p><code>ex == b::Union{Real,AbstractArray}</code></p><p>Requires expression to be affine.</p><h3>Example</h3><pre><code class="language-julia">julia&gt; A,b  = randn(10,5), randn(10);

julia&gt; x = Variable(5);

julia&gt; A*x == b</code></pre></li></ul><p><strong>Norm equality constraint</strong></p><ul><li><p><code>norm(x::AbstractExpression) == r::Number</code></p><p><span>$\| \mathbf{x} \| = r$</span></p></li></ul><p><strong>Binary constraint</strong></p><ul><li><p><code>x::AbstractExpression == (l, u)</code></p><p><span>$\mathbf{x} = \mathbf{l}$</span> or <span>$\mathbf{x} = \mathbf{u}$</span></p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L313-L343">source</a></section><h2><a class="nav-anchor" id="Smoothing-1" href="#Smoothing-1">Smoothing</a></h2><p>Sometimes the optimization problem might involve non-smooth terms which do not have efficiently computable proximal mappings. It is possible to <em>smoothen</em> these terms by means of the <em>Moreau envelope</em>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StructuredOptimization.smooth" href="#StructuredOptimization.smooth"><code>StructuredOptimization.smooth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">smooth(t::Term, gamma = 1.0)</code></pre><p>Smooths the nonsmooth term <code>t</code> using Moreau envelope:</p><div>\[f^{\gamma}(\mathbf{x}) = \min_{\mathbf{z}} \left\{ f(\mathbf{z}) + \tfrac{1}{2\gamma}\|\mathbf{z}-\mathbf{x}\|^2 \right\}.\]</div><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; x = Variable(4)
Variable(Float64, (4,))

julia&gt; x = Variable(4);

julia&gt; t = smooth(norm(x,1))
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L402-L422">source</a></section><h2><a class="nav-anchor" id="Duality-1" href="#Duality-1">Duality</a></h2><p>In some cases it is more convenient to solve the <em>dual problem</em> instead of the primal problem. It is possible to convert a problem into its dual by means of the <em>convex conjugate</em>.</p><p>See the <a href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/master/demos/TotalVariationDenoising.ipynb">Total Variation demo</a> for an example of such procedure.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.conj" href="#Base.conj"><code>Base.conj</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">conj(t::Term)</code></pre><p>Returns the convex conjugate transform of <code>t</code>:</p><div>\[f^*(\mathbf{x}) = \sup_{\mathbf{y}} \{ \langle \mathbf{y}, \mathbf{x} \rangle - f(\mathbf{y}) \}.\]</div><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; x = Variable(4)
Variable(Float64, (4,))

julia&gt; x = Variable(4);

julia&gt; t = conj(norm(x,1))
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/kul-forbes/StructuredOptimization.jl/blob/20b4f1de0516a8f5d73bd25ea36147fd64d18291/src/syntax/terms/proximalOperators_bind.jl#L370-L389">source</a></section><footer><hr/><a class="previous" href="../expressions/"><span class="direction">Previous</span><span class="title">Expressions</span></a><a class="next" href="../solvers/"><span class="direction">Next</span><span class="title">Solvers</span></a></footer></article></body></html>
